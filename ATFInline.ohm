ATFInline {
    lowercaseVowel
        = "a"
        | "e"
        | "i"
        | "u"

    uppercaseVowel
        = "A"
        | "E"
        | "I"
        | "U"

    aleph
        = "ʾ"
        | "'"

    timesChar
        = "×"

    cdliSpecialLowercase
        = "sz"
        | "ts"
        | "s,"
        | "t,"

    cdliSpecialUppercase
        = "SZ"
        | "TS"
        | "S,"
        | "T,"

    lowercaseConsonant
        = "b"
        | "d"
        | "g"
        | "ḫ"
        | "h"
        | "k"
        | "l"
        | "m"
        | "n"
        | "p"
        | "q"
        | "r"
        | "s"
        | "ṣ"
        | "š"
        | "ś"
        | "t"
        | "ṭ"
        | "w"
        | "y"
        | "z"

    uppercaseConsonant
        = "B"
        | "D"
        | "G"
        | "Ḫ"
        | "H"
        | "K"
        | "L"
        | "M"
        | "N"
        | "P"
        | "Q"
        | "R"
        | "S"
        | "Ṣ"
        | "Š"
        | "Ś"
        | "T"
        | "Ṭ"
        | "W"
        | "Y"
        | "Z"
        | "Ŋ"

    uppercaseCharacter
        = uppercaseVowel | cdliSpecialUppercase  | uppercaseConsonant | aleph
    lowercaseCharacter
        = lowercaseVowel | cdliSpecialLowercase | lowercaseConsonant | aleph

    elementalUppercaseConsonant
        = cdliSpecialUppercase | uppercaseConsonant | aleph

    elementalLowercaseConsonant
        = cdliSpecialLowercase | lowercaseConsonant | aleph

    openBracket
        = "["
    closedBracket
        = "]"


    // The following is taken straight from JTF
    valueSymbolPrefix
        = "d" | "m" | "f" | "p" | aleph | "I"

    nonValueSymbol
        = uppercaseCharacter | lowercaseCharacter

    valueSymbolSolo
        = valueSymbolPrefix nonValueSymbol

    bracketedUppercaseConsonant
        = openBracket elementalUppercaseConsonant closedBracket

    bracketedLowercaseConsonant
        = openBracket elementalLowercaseConsonant closedBracket

    plainLowercaseValue
        = (bracketedLowercaseConsonant? lowercaseVowel)+
        | (valueSymbolSolo nonValueSymbol)

    plainUppercaseValue
        = (bracketedUppercaseConsonant? uppercaseVowel)+ -- valueSymbol
        | nonValueSymbol -- nonValueSymbol
    // End JTF transcribed simple values


    // The following token definitions are taken from
    // JTF, with some name modifications
    subscriptDigit
        = "₀"|"₁"|"₂"|"₃"|"₄"|"₅"|"₆"|"₇"|"₈"|"₉"

    fraction
        = "1/2" | "1/3" | "1/4" | "2/3" | "5/6" | "1/8"

    numericTokens
        = fraction
        | subscriptDigit*
        | digit*

    numericEllipsesLowerToken
        = "n" nonValueSymbol
    numericEllipsesUpperToken
        = "N" nonValueSymbol
    numericEllipsesPlhdPlusToken
        = ("n" | "N") "+" digit* nonValueSymbol
    // End numeric tokens from JTF

    // Glosses definitions taken from JTF,
    // with some name modifications
    linguisticGlossOpen
        = "{{"
    linguisticGlossClosed
        = "}}"
    documentGlossOpen
        = "{("
    documentGlossClosed
        = ")}"

    // The close is the same as
    // the determinative gloss close
    scriptGlossOpen
        = "{%" digit

    determinativeGlossOpen
        = "{"
    determinativeGlossClosed
        = "}"
        
    // The grapheme is present but must be
    // excised for the correct meaning
    presenceExciseGlossOpen
        = "<<"
    presenceExciseGlossClosed
        = ">>"

    afterBoundaryGlossOpen
        = "<("
    afterBoundaryGlossClosed
        = ")>"
    afterGraphemeGlossOpen
        = "<("
    afterGraphemeGlossClosed
        = ")>"

    // The graphemes must be supplied for
    // the meaning but are not present
    presenceNeededGlossOpen
        = "<"
    presenceNeededGlossClosed
        = ">"
    
    inlineCommentOpen
        = "(#"
    inlineCommentClosed
        = "#)"

    // GDL Modifier Tokens
    modifierToken
        = "@v" -- variant
        | "@c" -- curved
        | "@f" -- flat
        | "@g" -- gunu
        | "@s" -- sheshig
        | "@t" -- tenu
        | "@n" -- nutillu
        | "@z" -- zidatenu
        | "@k" -- kabatenu
        | "@r" -- verticallyReflected
        | "@h" -- horizontallyReflected
        | "@" digit+ -- rotated

    // Allograph tokens
    allographCharacter
        = ~("x" | "X") (letter | digit)
    allograph
        = "~" allographCharacter+ -- custom
        | "~t" -- token
        | "~v" -- variant

    // GDL Operators
    operator
        = "." -- beside
        | "+" -- joining
        | (timesChar | "x") -- containing
        | "&" -- above
        | "%" -- crossing
        | "@" -- opposing
        | "3" (timesChar | "x") -- repeatedThree
        | "4" (timesChar | "x") -- repeatedFour
        | ":" -- reversed // From JTF
        | "/" -- alternative // From JTF

    // Field Tokens
    // See: http://oracc.ub.uni-muenchen.de/doc/help/editinginatf/lexicaltexts/index.html#h_fields
    fieldTokens
        = (",!sv" | "#") -- signValue // a sign value follows
        | (",!pr" | "\"") -- pronunciation // a pronunciation follows
        | (",!sg" | "~") -- sign // a sign follows
        | (",!sn" | "|") -- ancientSignName // An ancient sign name follows
        | (",!eq" | "=") -- equivalent // Column that follows is  a translation or synonym
        | (",!wp" | "!wp" | "^") -- default // A word or phrase follows (is the default column type)

    builtinSignListName
        = "ABZ" digit+
        | "BAU" digit+
        | "HZL" digit+
        | "KWU" digit+
        | "LAK" digit+
        | "MEA" digit+
        | "MZL" digit+
        | "REC" digit+
        | "RSP" digit+
        | "ZATU" digit+

    genericSignListName
        = (upper upper | upper) "SL" digit+

    numericSignListName
        = "N" digit+
        
        

}
